#derived from verilog.snippets
# a header 
snippet head
	//
	//File: ${1:`expand('%:t')`}
	//Device: ${2}
	//Created: ${3: `strftime("%c")`}
	//Description: ${4:blablabla}
	//Revisions: ${5:listed below}
	//
# the revision details
snippet rev
	
	//`strftime("%c")`: ${1:created}
# module extract
snippet mod
	module ${1:name_of_module} 
	(
		${2:input}
	);
	endmodule: $1
# module with parameters
snippet mp
	module ${1:name_of_module} 
	#(
	//parameter declaration
		parameter
	)
	(
		${2:input}
	);
	endmodule: $1
# package
snippet pk
	package ${1};
	endpackage
# class
snippet cl
	class ${1:foo};
		function new();
		endfunction
	endclass: $1
# constraint
snippet cons
	constraint ${1}{
		${2}
	};
# property
snippet pro
	property ${1};
	endproperty
# sequence
snippet seq
	sequence ${1};
	endsequence
# covergroup
snippet cov
	covergroup ${1};
	endgroup
# function
snippet fun
	function ${1:void} ${2:foo} (
	);
		${4}
	endfunction: $2
# task
snippet task
	task ${1:foo} (
	);
	endtask: $1
# initial block
snippet ini
	initial
	begin
		${1:}
	end
# begin-end pair
snippet beg
	begin
		${1:}
	end
# fork-join pair
snippet fo
	fork
		${1:}
	join
# a wire variables declare
snippet wire
	wire [${2:7}:${1:0}] ${3:/*variables*/};
# a reg variables declare 
snippet reg
	reg [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare
snippet input
	input [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet output
	output [${2:7}:${1:0}] ${3:/*variables*/};
# ports declare 
snippet inout
	inout [${2:7}:${1:0}] ${3:/*variables*/};
# module inst boost
snippet inst a autoinst snip
	${1:name_of_module} m$1 
	(/*autoinst*/);
# inst with parameters
snippet ip
	${1:name_of_module} 
	#(/*autoinstparam*/)
	m$1 
	(/*autoinst*/);

# else if statement
# snippet eif
# 	else if (${1} ${2:=}= ${3})
# 	begin
# 		${4:/*statements*/}
# 	end
# if statement
snippet if
	if (${1:a} ${2:=}= ${3:b})
	begin
		${4:/*statements*/}
	end
# assign statement
snippet ass
	assign
		${1} = ${2};
# always block statement
snippet alw a combinational always block
	always @(${1:/*autosense*/})
	begin
		${2:/*statements*/}
	end
snippet alw a clk triggered always block
	always @(${1:pos}edge ${2:clk})
	begin
		${3:/*statements*/}
	end
snippet alw a clk triggered always block with reset signal
	always @(${1:pos}edge ${2:clk} or ${3:neg}edge ${4:rst_n})
	begin
		if (!$4)
		begin
			${5:/*autoreset*/}
		end
		else
		begin
			${6:/*statements*/}
		end
	end
# time scale statement
snippet ts
	`timescale 1ns/${1:100ps}
# include statement
snippet inc
	`include "${1:define}.v"
# else block
snippet else
	else
	begin
		${1}
	end
# an inc snip
snippet acc
	${1:var} <= $1 + ${2:8}'d1;
# state machine snip
snippet sm
	//state reg
	(* syn_encoding = "safe" *)reg [${1:7}:0] ns_$2, cs_${2:mmm};
	//state parameters
	localparam 
		${5:sIDLE} = 0,
	always @(posedge ${3:clk} or negedge ${4:rst_n})
		if (!$4)
			cs_$2 <= $5;
		else
			cs_$2 <= ns_$2;

	always @(*)
	begin
		ns_$2 = cs_$2;
		case (cs_$2)
			$5:
			default:
				ns_$2 = $5;
		endcase
	end
# parameterized bit oprand
snippet p0
	{(${1:pWIDTH}){1'b0}};
snippet p1
	{{(${1:pWIDTH}-1){1'b0}}, 1'b1};
# Altera Synthesis Attributes
snippet sa full case
	(* full_case *)
snippet sa parallel case
	(* parallel_case *)
snippet sa keep
	(* keep *)
snippet sa preserve
	(* preserve *)
snippet sa noprune
	(* noprune *)
snippet sa encoding
	(* syn_encoding = "safe" *)
#display
snippet dis basic
	$display("${1}");
snippet dis with timestamp
	$display("[@%t]----->", $stime);
# info
snippet info info
	`uvm_info("${2}", "${3}", UVM_${1:MEDIUM})
snippet info warning
	`uvm_warning("${1}", "${2}")
snippet info error
	`uvm_error("${1}", "${2}")
snippet info fatal
	`uvm_fatal("${1}", "${2}")
# uvm components
snippet com component
	class ${1:foo} extends uvm_${2:component};
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com test
	class ${1:foo} extends uvm_test;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com env
	class ${1:foo} extends uvm_env;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com agent
	class ${1:foo} extends uvm_agent;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com scoreboard
	class ${1:foo} extends uvm_scoreboard;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com driver
	class ${1:foo} extends uvm_driver;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com monitor
	class ${1:foo} extends uvm_monitor;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com subscriber
	class ${1:foo} extends uvm_subscriber;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
snippet com sequencer
	class ${1:foo} extends uvm_sequencer;
		`uvm_component_utils($1) ;
		function new(string name = "$1", uvm_component parent);
			super.new(name, parent);
		endfunction
		virtual function void build_phase(uvm_phase phase);
			super.build_phase(phase);
		endfunction
	endclass
# uvm objects
snippet obj object
	class ${1:foo} extends uvm_${2:object};
		`uvm_object_utils($1) ;
		function new(string name = "$1");
			super.new(name);
		endfunction
	endclass
snippet obj transaction
	class ${1:foo} extends uvm_sequence_item;
		`uvm_object_utils($1) ;
		function new(string name = "$1");
			super.new(name);
		endfunction
	endclass
snippet obj sequence
	class ${1:foo} extends uvm_sequence;
		`uvm_object_utils($1) ;
		function new(string name = "$1");
			super.new(name);
		endfunction
		task body();
		endtask
	endclass
# config db 
snippet set config db
	uvm_config_db #(${1})::set(${2:null}, "${3:*}", "${4:cif}", $4);
snippet get config db
	uvm_config_db #(${1})::get(${2:null}, "${3:*}", "${4:cif}", $4);
# phase 
snippet pha phase
	function void ${1:connect}_phase(uvm_phase phase);
		super.$1_phase(phase);
	endfunction
snippet pha connect
	function void connect_phase(uvm_phase phase);
		super.connect_phase(phase);
	endfunction
snippet pha report
	function void report_phase(uvm_phase phase);
		super.report_phase(phase);
	endfunction
snippet pha task phase
	task ${1:main}_phase(uvm_phase phase);
		phase.raise_objection(this);
		super.$1_phase(phase);
		phase.drop_objection(this);
	endtask
# uvm field
snippet field uvm_field
	\`uvm_object_utils_begin(${1:trans});
		\`uvm_field_${2:int}(${3}, ${4:UVM_ALL_ON})
	\`uvm_object_utils_end
# end of systemverilog snippets

